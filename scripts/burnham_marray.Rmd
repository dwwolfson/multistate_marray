---
title: "3-(st)age joint-encounter m-arrays"
author: "Todd Arnold"
date: "27-October-2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Live-dead multistate m-arrays with unknown age classes

This document demonstrates potential model structures for estimating survival and encounter probabilities using joint live-dead data for 3 age-classes where at least some individuals are of unknown (st)age at time of marking. The original motivation was for Giant Canada Geese that can only be differentiated as hatch-year (HY) and after-hatch-year (AHY) at time of banding. Geese and other "k-selected" species have deferred breeding and evidence suggests that models with 3 or more age-classes are necessary to accurately describe vital rates. However, simulation modeling indicates that if AHY individuals cannot be aged at time of capture, survival of HY and SY individuals and dead encounter probabilities of SY individuals will be biased, hence the motivation to develop efficient and reliable models using joint-encounter data. The size and complexity of goose data sets (thousands of releases, decades of data) precludes use of individual state-space approaches, hence the secondary objective of extending the multi-state m-array approach developed for cormorants in Schaub & Kery (2021) to additional model structures. 

```{r, warning=FALSE, message=FALSE}
# load required packages
library(IPMbook)
library(jagsUI)
```


### Scenario 1: Burnham formulation with temporally variable pi

This scenario mimics long-term live-encounter data at a fixed location (e.g. arctic goose colony) with dispersed dead recoveries from throughout the population's range: 
- Survival (s) varies by year and age class (state 1 = hatch year HY, state 2 = second year SY, and state 3 = after second year ASY), but only 2 age classes can be recognized at time of banding (HY and state 4: after hatch year (AHY), which are pooled SY & ASY). 
- The parameter pi estimates the proportion of AHY newly marked each year that are SY at time of banding (all will transition to ASY if they survive the coming year, but pi proportion will have SY vital rates and (1-pi) proportion will have ASY vital rates); pi is allowed to vary by year to accommodate annual variation in recruitment and hence variable proportions of SY to ASY in the population. 
- Fidelity (F) is the annual proportion of the surviving population that returns to the breeding colony each year, with (1-F) permanently dispersing to other colonies where they are no longer available for recapture/resighting during the annual summer banding period. If individuals survive and disperse, they transition to state 6 (dispersed SY) or state 7 (dispersed ASY), where they are still vulnerable to hunting and may be encountered dead, but can no longer be observed alive (p = 0). F also varies by year and age class. 
- If individuals die and are recovered dead (r = Seber recovery probability conditional on death), they are observed in state 4 with probability of 1 (i.e. the encounter probability is inserted into the state-transition matrix, per Kery & Schaub). All "recovered dead" age classes are collapsed within this single state to simplify dimensions of the state-transition matrix.
- Finally, if individuals survive and return to the breeding colony, they can be observed alive in states 2 or 3 with probability (p). Indexing for this parameter is based on age and year when observed, not age and year when released, hence a HY individual released in year 1 and returning to the colony in year 5 will have encounter probability p[2,5], not p[1,4]. Priors for p are generated for HY individuals although not used in this model, but probability of entry could be useful for estimating population sizes at time of capture, including ratios of population size (e.g. N1/(N2+N3) = fecundity).   

```{r}
# code adapted from Schaub & Kery, 2021, chapter 18

cat(file = "burnham_marray.txt", "
model {

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1. SPECIFY PRIORS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# pi is proportion of AHY that are SY at time of banding
pi.mu ~ dnorm(0,0.33)
pi.sd ~ dunif(0.01, 2); pi.tau <- pow(pi.sd, -2)
for (t in 1:(n_yrs)){
  logit.pi[t] ~ dnorm(pi.mu, pi.tau)
  logit(pi[t]) <- logit.pi[t]
}

# age-specific hyperparameters 
# include code for temporal covariation across age classes?
for (a in 1:n_ages){
  s.mu[a] ~ dnorm(0, 0.33) # survival
  s.sd[a] ~ dunif(0.01, 2); s.tau[a] <- pow(s.sd[a], -2) # annual variation, convert to precision
  F.mu[a] ~ dnorm(0, 0.33) # fidelity to breeding site
  F.sd[a] ~ dunif(0.01, 2); F.tau[a] <- pow(F.sd[a], -2)
  r.mu[a] ~ dnorm(0, 0.33) # seber recovery probability
  r.sd[a] ~ dunif(0.01, 2); r.tau[a] <- pow(r.sd[a], -2)
  p.mu[a] ~ dnorm(0, 0.33)  # recapture probability, same site
  p.sd[a] ~ dunif(0.01, 2); p.tau[a] <- pow(p.sd[a], -2)
  for (t in 1:(n_yrs)){
    logit.s[a,t] ~ dnorm(s.mu[a], s.tau[a])
    logit(s[a,t]) <- logit.s[a,t] # backtransform to real scale 
    logit.F[a,t] ~ dnorm(F.mu[a], F.tau[a])
    logit(F[a,t]) <- logit.F[a,t]  
    logit.r[a,t] ~ dnorm(r.mu[a], r.tau[a])
    logit(r[a,t]) <- logit.r[a,t]  
    logit.p[a,t] ~ dnorm(p.mu[a], p.tau[a])
    logit(p[a,t]) <- logit.p[a,t]  
  } # t
} # a

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2. Multistate state-transition and observation matrix (a vector suffices)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# alive resident 1: HY, 2: SY, 3: ASY, 4: AHY
# recovered dead, all ages: 5 (thanks Thomas!)
# alive emigrant 6: SY, 7: ASY (unobservable states)
# dead or unobserved (absorbing)

for (t in 1:(n_yrs-1)){
  # departure HY release
   psi[1,t,1] <- 0
   psi[1,t,2] <- s[1,t]*F[1,t] # survive to SY, remain
   psi[1,t,3] <- 0
   psi[1,t,4] <- 0
   psi[1,t,5] <- (1-s[1,t])*r[1,t] # die, recovered
   psi[1,t,6] <- s[1,t]*(1-F[1,t]) # survive, emigrate
   psi[1,t,7] <- 0
   psi[1,t,8] <- (1-s[1,t])*(1-r[1,t]) # die, not recovered
  # departure SY resident
   psi[2,t,1] <- 0
   psi[2,t,2] <- 0
   psi[2,t,3] <- s[2,t]*F[2,t]
   psi[2,t,4] <- 0
   psi[2,t,5] <- (1-s[2,t])*r[2,t]
   psi[2,t,6] <- 0
   psi[2,t,7] <- s[2,t]*(1-F[2,t])
   psi[2,t,8] <- (1-s[2,t])*(1-r[2,t])
  # departure ASY resident
   psi[3,t,1] <- 0
   psi[3,t,2] <- 0
   psi[3,t,3] <- s[3,t]*F[3,t]
   psi[3,t,4] <- 0
   psi[3,t,5] <- (1-s[3,t])*r[3,t]
   psi[3,t,6] <- 0
   psi[3,t,7] <- s[3,t]*(1-F[3,t])
   psi[3,t,8] <- (1-s[3,t])*(1-r[3,t])
  # departure AHY resident (all become ASY, but uncertain departure states)
   psi[4,t,1] <- 0
   psi[4,t,2] <- 0
   psi[4,t,3] <- pi[t]*s[2,t]*F[2,t] + (1-pi[t])*s[3,t]*F[3,t]
   psi[4,t,4] <- 0
   psi[4,t,5] <- pi[t]*(1-s[2,t])*r[2,t] + (1-pi[t])*(1-s[3,t])*r[3,t]
   psi[4,t,6] <- 0
   psi[4,t,7] <- pi[t]*s[2,t]*(1-F[2,t]) + (1-pi[t])*s[3,t]*(1-F[3,t])
   psi[4,t,8] <- pi[t]*(1-s[2,t])*(1-r[2,t]) + (1-pi[t])*(1-s[3,t])*(1-r[3,t])
  # recently dead (simplified coding, all transition to long dead) 
   psi[5,t,1:8] <- c(0, 0, 0, 0, 0, 0, 0, 1)
  # departure SY emigrant
   psi[6,t,1] <- 0
   psi[6,t,2] <- 0
   psi[6,t,3] <- 0
   psi[6,t,4] <- 0
   psi[6,t,5] <- (1-s[2,t])*r[2,t]
   psi[6,t,6] <- 0
   psi[6,t,7] <- s[2,t]
   psi[6,t,8] <- (1-s[2,t])*(1-r[2,t])
  # departure ASY emigrant
   psi[7,t,1] <- 0
   psi[7,t,2] <- 0
   psi[7,t,3] <- 0
   psi[7,t,4] <- 0
   psi[7,t,5] <- (1-s[3,t])*r[3,t]
   psi[7,t,6] <- 0
   psi[7,t,7] <- s[3,t]
   psi[7,t,8] <- (1-s[3,t])*(1-r[3,t])
  # already dead (simplified coding) 
   psi[8,t,1:8] <- c(0, 0, 0, 0, 0, 0, 0, 1)

 # observation matrix 
   po[1,t] <- 1 # HY releases, all seen (but condition on capture so ignored)
   po[2,t] <- p[2,t] # captured as SY where last captured
   po[3,t] <- p[3,t] # captured as ASY where last captured
   po[4,t] <- 1 # AHY releases
   po[5,t] <- 1 # dead recoveries, r in state-transition matrix
   po[6,t] <- 0 # SY emigrants, unobservable
   po[7,t] <- 0 # ASY emigrant, unobservable
   po[8,t] <- 0 # dead unrecovered or long dead

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Miche's magic code, never needs to be modified
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 # Calculate probability of non-encounter (dq) and reshape the array for the encounter probabilities
      for (k in 1:ns){
         dp[k,t,k] <- po[k,t]
         dq[k,t,k] <- 1-po[k,t]} #k
      for (k in 1:(ns-1)){
         for (m in (k+1):ns){
            dp[k,t,m] <- 0
            dq[k,t,m] <- 0} #m
      } #k
      for (k in 2:ns){
         for (m in 1:(k-1)){
            dp[k,t,m] <- 0
            dq[k,t,m] <- 0} #m
      } #k
   } #t

# Define the multinomial likelihood
for (t in 1:((n_yrs-1)*ns)){
   marr[t,1:(n_yrs*ns-(ns-1))] ~ dmulti(pri[t,], rel[t])
} # t

# Define the cell probabilities of the multistate m-array
for (t in 1:(n_yrs-2)){
   U[(t-1)*ns+(1:ns), (t-1)*ns+(1:ns)] <- ones
   for (j in (t+1):(n_yrs-1)){
   ## fixed based on published erratum of book code
      U[(t-1)*ns+(1:ns), (j-1)*ns+(1:ns)] <- U[(t-1)*ns+(1:ns), (j-2)*ns+(1:ns)] %*% psi[,j-1,] %*% dq[,j-1,] # fixed
   } #j
} #t
U[(n_yrs-2)*ns+(1:ns), (n_yrs-2)*ns+(1:ns)] <- ones

# Diagonal
for (t in 1:(n_yrs-2)){
   pri[(t-1)*ns+(1:ns),(t-1)*ns+(1:ns)] <- U[(t-1)*ns+(1:ns),(t-1)*ns+(1:ns)] %*% psi[,t,] %*% dp[,t,]
   # Above main diagonal
   for (j in (t+1):(n_yrs-1)){
      pri[(t-1)*ns+(1:ns), (j-1)*ns+(1:ns)] <- U[(t-1)*ns+(1:ns), (j-1)*ns+(1:ns)] %*% psi[,j,] %*% dp[,j,]
   } #j
} #t
pri[(n_yrs-2)*ns+(1:ns), (n_yrs-2)*ns+(1:ns)] <- psi[,n_yrs-1,] %*% dp[,n_yrs-1,]

# Below main diagonal
for (t in 2:(n_yrs-1)){
   for (j in 1:(t-1)){
      pri[(t-1)*ns+(1:ns),(j-1)*ns+(1:ns)] <- zero
   } #j
} #t

# Last column: probability of non-recapture
for (t in 1:((n_yrs-1)*ns)){
   pri[t,(n_yrs*ns-(ns-1))] <- 1-sum(pri[t,1:((n_yrs-1)*ns)])
} #t
} # end model
")

parms <- c("s.mu", "s.sd", "F.mu", "F.sd", "r.mu", "r.sd", "p.mu", "p.sd", "pi.mu", "pi.sd",   
           "pi", "s", "F", "r", "p")

```

Simulate data under this scenario.

```{r}
# specify hyper-parameters and annual values for simulation, create transition array, save true values to file

n_yrs <- 20 # length of banding-recovery
n_stages <- 3
n_states <- 8

# create empty vectors for storing true values of stage-specific hyperparameters
r.mu <- r.sd <- p.mu <- p.sd <- s.mu <- s.sd <- F.mu <- F.sd <- g.mu <- g.sd <- numeric()
# specify age-specific means and variances
# note the code allows biologically unlikely scenarios like juvs surviving better than adults
r.mu <- qlogis(runif(3, 0.05, 0.3))
r.sd <- runif(3, 0.1, 1)
p.mu <- qlogis(runif(3, 0.05, 0.3))
p.sd <- runif(3, 0.1, 1)
s.mu <- qlogis(runif(3, 0.6, 0.9))
s.sd <- runif(3, 0.1, 1)
F.mu <- qlogis(runif(3, 0.7, 0.95))
F.sd <- runif(3, 0.1, 0.5) # allowing less annual variation for F
pi.mu <- qlogis(runif(1, 0.1, 0.3))
pi.sd <- runif(1, 0.1, 1)
pi <- plogis(rnorm(n_yrs, pi.mu, pi.sd))

# generate matrices of age-specific vital rates
r <- p <- s <- F <- matrix(NA, nrow = n_stages, ncol = n_yrs)
for (a in 1:n_stages){
  r[a,1:n_yrs] <- plogis(rnorm(n_yrs, r.mu[a], r.sd[a]))  
  p[a,1:n_yrs] <- plogis(rnorm(n_yrs, p.mu[a], p.sd[a]))  
  s[a,1:n_yrs] <- plogis(rnorm(n_yrs, s.mu[a], s.sd[a]))  
  F[a,1:n_yrs] <- plogis(rnorm(n_yrs, F.mu[a], F.sd[a]))  
}

# create array of transition probabilities
psi <- array(NA, dim = c(n_states, n_yrs, n_states))
for (i in 1:n_yrs){
    psi[1,i,1:8] <- c(0, s[1,i]*F[1,i], 0, 0, (1-s[1,i])*r[1,i], s[1,i]*(1-F[1,i]), 0, (1-s[1,i])*(1-r[1,i]))
    psi[2,i,1:8] <- c(0, 0, s[2,i]*F[2,i], 0, (1-s[2,i])*r[2,i], 0, s[2,i]*(1-F[2,i]), (1-s[2,i])*(1-r[2,i]))
    psi[3,i,1:8] <- c(0, 0, s[3,i]*F[3,i], 0, (1-s[3,i])*r[3,i], 0, s[3,i]*(1-F[3,i]), (1-s[3,i])*(1-r[3,i]))
    psi[4,i,1:8] <- c(0, 0, pi[i]*s[2,i]*F[2,i] + (1-pi[i])*s[3,i]*F[3,i], 0, 
                      pi[i]*(1-s[2,i])*r[2,i] + (1-pi[i])*(1-s[3,i])*r[3,i], 0, 
                      pi[i]*s[2,i]*(1-F[2,i]) + (1-pi[i])*s[3,i]*(1-F[3,i]), 
                      pi[i]*(1-s[2,i])*(1-r[2,i]) + (1-pi[i])*(1-s[3,i])*(1-r[3,i]))
    psi[5,i,1:8] <- c(0, 0, 0, 0, 0, 0, 0, 1)
    psi[6,i,1:8] <- c(0, 0, 0, 0, (1-s[2,i])*r[2,i], 0, s[2,i], (1-s[2,i])*(1-r[2,i]))
    psi[7,i,1:8] <- c(0, 0, 0, 0, (1-s[3,i])*r[3,i], 0, s[3,i], (1-s[3,i])*(1-r[3,i]))
    psi[8,i,1:8] <- c(0, 0, 0, 0, 0, 0, 0, 1)
}
# verify all calculations sum to 1
#rowSums(psi[1:8,n_yrs,])

# code to save true parameters used for simulation
true_parms <- rbind(F, p, r, s, pi)
write.csv(true_parms, "true_parms.csv")
true_hypers <- rbind(F.mu, F.sd, r.mu, r.sd, p.mu, p.sd, s.mu, s.sd, rep(pi.mu,3), rep(pi.sd,3))
write.csv(true_hypers, "true_hypers.csv")

```


Simulate capture histories and manipulate into m-array formulation using code from IPMbook.

```{r}
# set annual releases
#HY_banded <- 1000 # reasonable real-world example
HY_banded <- 10000 # higher default value to better assess model performance
#HY_banded <- 100000 # increased even more to better assess identifiability
#SY_banded <- 0 # can incorporate known ages if they exist
#ASY_banded <- 0 
#AHY_banded <- 1000 
AHY_banded <- 10000 
#AHY_banded <- 100000 

rel_HY <- rep(HY_banded, n_yrs)
#rel_SY <- rep(SY_banded, n_yrs)
#rel_ASY <- rep(ASY_banded, n_yrs)
rel_AHY <- rep(AHY_banded, n_yrs)
rel <- cbind(rel_HY, rel_AHY) # modify if SY and ASY releases
### simulation code doesn't seem to work if binding columns of all 0s but that could likely be fixed
n_cohorts <- dim(rel)[2]
rel_cohort <- c(1,4) # modify to c(1:4) if releasing known SY and ASY too

# create empty matrix to hold truth and CH data
truth <- CH <- matrix(0, nrow = sum(rel), ncol = n_yrs)

c <- 1 # set row counter to 1
for (i in 1:(n_yrs-1)){
  for (j in 1:n_cohorts){ # release cohorts
    for (k in 1:rel[i,j]){
      truth[c,i] <- CH[c,i] <- rel_cohort[j] 
      for (m in (i+1):n_yrs){
        truth[c,m] <- sample(1:n_states, size = 1, prob = psi[truth[c,m-1], m-1, 1:n_states])
        CH[c,m] <- ifelse(truth[c,m] == 2,
                          truth[c,m]*rbinom(1, 1, p[2, m]), # chance of being seen if SY
                          ifelse(truth[c,m] == 3,
                                 truth[c,m]*rbinom(1, 1, p[3, m]), # chance of being seen if ASY
                                 truth[c,m]))
      } # m
    c <- c + 1
    } # k
  } # j
} # i
# no information in final year except release status so no Brownie's f in final year
for (i in n_yrs:n_yrs){
  for (j in 1:2){ # release cohorts
    for (k in 1:rel[i,j]){
      CH[c,i] <- rel_cohort[j]
      c <- c + 1
    } # k
  } # j
} # i

# convert 6:8 to 0 (unobservable states)
ch <- CH
ch[ch[,] >= 6] <- 0
# inspect
#head(ch)
#tail(ch)

# convert to multistate CH using M Schaub IPM book code
marr <- marray(ch, unobs = 3)

```


Bundle data and submit to jags 

```{r, results = 'hide'}
# bundle data for jags
jags.data <- list(n_yrs = n_yrs,
                  n_ages = n_stages,
                  ns = n_states, # number of states
                  marr = marr, 
                  rel = rowSums(marr),
                  ones = diag(n_states), 
                  zero = matrix(0, ncol = n_states, nrow = n_states))

# MCMC settings
#ni <- 15000; nb <- 5000; nt <- 1; nc <- 4; na <- 1000 # (~140 min, all except penultimate converged and well mixed)
ni <- 7500; nb <- 2500; nt <- 1; nc <- 4; na <- 1000 # (~60 min, most parameters converged)
#ni <- 1500; nb <- 500; nt <- 1; nc <- 4; na <- 1000 # (exploratory, ~15 min, most converge, hypers need more time)
iterations <- ((ni - nb)/nt)*nc

# Call JAGS from R and check convergence
out1 <- jagsUI(jags.data, inits = NULL, parms, "burnham_marray.txt", 
               n.iter = ni, n.burnin = nb, n.chains = nc, n.thin = nt, n.adapt = na, 
               parallel = TRUE)

# max(unlist(out1$Rhat)) 
# print(out1)
# traceplot(out1)
```

Plot parameter estimates 

```{r, echo = FALSE}
par(mfrow = c(2,2)); par(mar = c(3,5,2,0))
plot(s[1,1:19], out1$mean$s[1,1:19], xlim = c(0.5,1), ylim = c(0.5,1), ylab = "Estimated survival", xlab = "True survival")
segments(s[1,1:19], out1$q2.5$s[1,1:19], s[1,1:19], out1$q97.5$s[1,1:19])
points(s[2,1:19], out1$mean$s[2,1:19], col = "red")
segments(s[2,1:19], out1$q2.5$s[2,1:19], s[2,1:19], out1$q97.5$s[2,1:19], col = "red")
points(s[3,1:19], out1$mean$s[3,1:19], col = "blue")
segments(s[3,1:19], out1$q2.5$s[3,1:19], s[3,1:19], out1$q97.5$s[3,1:19], col = "blue")
abline(a = 0, b = 1)
legend(0.5, 1, legend = c("HY","SY","ASY"), text.col = c("black","red","blue"), bty = 'n')

plot(F[1,1:19], out1$mean$F[1,1:19], xlim = c(0.5,1), ylim = c(0.5,1), ylab = "Estimated fidelity", xlab = "True fidelity")
segments(F[1,1:19], out1$q2.5$F[1,1:19], F[1,1:19], out1$q97.5$F[1,1:19])
points(F[2,1:19], out1$mean$F[2,1:19], col = "red")
segments(F[2,1:19], out1$q2.5$F[2,1:19], F[2,1:19], out1$q97.5$F[2,1:19], col = "red")
points(F[3,1:19], out1$mean$F[3,1:19], col = "blue")
segments(F[3,1:19], out1$q2.5$F[3,1:19], F[3,1:19], out1$q97.5$F[3,1:19], col = "blue")
abline(a = 0, b = 1)
legend(0, 1, legend = c("HY","SY","ASY"), text.col = c("black","red","blue"), bty = 'n')

plot(r[1,1:19], out1$mean$r[1,1:19], xlim = c(0,0.6), ylim = c(0,0.6), ylab = "Estimated recovery", xlab = "True recovery")
segments(r[1,1:19], out1$q2.5$r[1,1:19], r[1,1:19], out1$q97.5$r[1,1:19])
points(r[2,1:19], out1$mean$r[2,1:19], col = "red")
segments(r[2,1:19], out1$q2.5$r[2,1:19], r[2,1:19], out1$q97.5$r[2,1:19], col = "red")
points(r[3,1:19], out1$mean$r[3,1:19], col = "blue")
segments(r[3,1:19], out1$q2.5$r[3,1:19], r[3,1:19], out1$q97.5$r[3,1:19], col = "blue")
abline(a = 0, b = 1)
legend(0, 1, legend = c("HY","SY","ASY"), text.col = c("black","red","blue"), bty = 'n')

# for simulation, p indexed to recapture year, not release year
plot(p[2,2:20], out1$mean$p[2,1:19], xlim = c(0,0.6), ylim = c(0,0.6), ylab = "Estimated recapture", xlab = "True recapture", col = "red")
segments(p[2,2:20], out1$q2.5$p[2,1:19], p[2,2:20], out1$q97.5$p[2,1:19], col = "red")
points(p[3,2:20], out1$mean$p[3,1:19], col = "blue")
segments(p[3,2:20], out1$q2.5$p[3,1:19], p[3,2:20], out1$q97.5$p[3,1:19], col = "blue")
abline(a = 0, b = 1)
legend(0, 1, legend = c("HY","SY","ASY"), text.col = c("black","red","blue"), bty = 'n')

par(mfrow = c(1,2))
plot(pi[1:19], out1$mean$pi[1:19], xlim = c(0,0.6), ylim = c(0,0.6), ylab = "Estimated SY proportion", xlab = "True SY proportion")
segments(pi[1:19], out1$q2.5$pi[1:19], pi[1:19], out1$q97.5$pi[1:19])
abline(a = 0, b = 1)

true_hyper <- c(s.mu, F.mu, r.mu, p.mu[2:3], pi.mu)
est_hyper <- c(out1$mean$s.mu, out1$mean$F.mu,  out1$mean$r.mu, out1$mean$p.mu[2:3], out1$mean$pi.mu)

plot(est_hyper, pch = 19, col = "blue", cex = 0.8, main = "Logit-scale hyper means", xlab = "True", ylab = "Estimated")
points(true_hyper, col = "red")
legend(0, 0, legend = c("Estimates", "Truth"), text.col = c("blue", "red"), bty = "n")

```

^^ Note: large CRI for annual estimates are usually associated with the final interval (parameter confounding) or sometimes the first interval (inability to estimate pi in year 1).
